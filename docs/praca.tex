\documentclass[a4paper]{article}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

% oprócz formatu papieru zdefiniowanego na początku (A4) możemy
% jeszcze określić wielkość „obszaru zadrukowanego”:
\usepackage[body={17cm,24cm}]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% aby ustalić, że plik źródłowy używa kodowania UTF-8:
%-----------------------------------------------------------
\usepackage[utf8]{inputenc}
% jeśli jedynie chcemy wykorzystywać polskie (lub inne) 
% znaki diakrytyczne wystarczy użyć pakietu "fontenc"
% z parametrem "OT4":
%\usepackage[OT4]{fontenc}
% jeśli piszemy po polsku, należy zamiast powyższego użyć:
\usepackage{polski}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\section{Streszczenie}
% Poniższy akapit zawiera przykłady użycia „niełamliwej spacji” w celu uniknięcia
% „wiszących liter” na końcach wiersza – zjawisko uważne za błąd w polskiej typografii.
Poniższa praca zawiera opis biblioteki „Ash” służącej do funkcjonalnego testowania
hybrydowych aplikacji mobilnych stworzonych przy użyciu Adobe PhoneGap lub
Apache Cordova. Ash pozwala na testowanie zachowania się aplikacji w~różnorodnych
realistycznych scenariuszach, które bywają trudne do symulowania przez inne narzędzie, takich jak poruszanie się użytkownika,
obrót ekranu, utrata dostępu do sieci oraz~inne. Dzięki wykorzystaniu hybrydowego charakteru aplikacji
możliwa jest emulacja zachowania, co wpływa na większy realizm testów, a tym samym na wiarygodność ich wyników. Innymi
zaletami bliblioteki są elastyczna struktura testów, która ułatwia utrzymywanie
testów i budowanie złożonych scenariuszy z prostych testów-kroków oraz
możliwość wykorzystania asercji w~aplikacji poza testami.
Możliwe jest także wykorzystanie Ash do testowania mobilnych wersji stron internetowych. 

\section{Wprowadzenie}
\subsection{Hybrydowe aplikacje mobilne}
Mówiąc o natywnej aplikacji mobilnej mamy na myśli apliakcję tworzoną z myślą o konkretnej platformie (Android, iOS, itp.) przy użyciu narzuconych przez twórcę platformy narzędzi (Java, Objective-C, itd.). Aplikacje mobile web są to z kolei aplikacje webowe zoptymalizowane po kątem urządzeń natywnych.
Adobe PhoneGap oraz jej odpowiednik o otwartym źródle Apache Cordova, to
dwie popularne biblioteki pozwalajace na tworzenie hybrydowych aplikacji
mobilnych, tj. aplikacji które łączą w sobie zalety aplikacji natywnych oraz aplikacji
typu mobile web. Zasada działania tego typu aplikacji jest w założeniu prosta i
polega na wykorzystaniu komponentów, które dalej nazywać będziemy WebView.
Kontrolki te są dostępne na każdej nowoczesnej platoformie i pozwalają nam na
wyświetalnie stron internetowych z wnętrza natywnych aplikacji mobilnych. 
W momencie startu aplikacja hybrydowa tworzy WebView oraz ładuje do niego zasoby z określonego adresu (lokalnego lub zdalnego), które są wyświetlane w WebView. Najczęściej tym zasobem jest aplikacja stworzona przy użyciu technologii webowych.     

% tabelki w LaTeX-u też da się robić, chociaż najczytelniej to może nie wygląda
% więcej na temt tabelek można poczytac np. na http://en.wikibooks.org/wiki/LaTeX/Tables
\begin{center}
    \begin{tabular}{ |  p{2cm} | p{4cm} | p{4cm} | p{4cm} |}
    \hline
   			& Aplikacje natywne        & Aplikacje hybrydowe 	& Aplikacje mobile web 			\\ \hline
    Narzędzia	& Zależne od platformy	&   Narzędzia webowe	& 	Narzędzia webowe			\\ \hline
    Instalacja	&        Wymagana               &	 Wymagana         	& 		Nie wymagana		\\ \hline
    Wydajność	& 	Bardzo dobra		&Ograniczona przez przeglądarkę&Ograniczona przez przeglądarkę\\ \hline
    Możliwość monetyzacji
    			&  Pobranie, reklamy, subskrybcje  & Pobranie, reklamy, subskrybcje & Reklamy, subskrybcje \\ \hline
    Dostęp do urządzenia
    			& 	Tak, pełen  	         &Najważniejsze funkcjonalności& Ograniczony        \\ \hline
    \end{tabular}
\end{center}

Takie podejście ma wiele zalet. Dzięki temu, że do tworzenia aplikacji hybrydowych wykorzystywane są technologie
znane z zastosowań intenetowych, koszt tworzenia aplikacji i czas dostarczenia
gotowego rozwiązania na rynek są znacznie zredukowane. Aplikacje tego typu są też
z założenia wieloplatformowe. Używając PhoneGap z tego samego kodu źródłowego
możemy stworzyć aplikacje na platformę Android, iOS, Blackberry, WebOS,
Windows Phone, Symbiana i Bada. Dodatkowo popularność narzędzi internetowych
ułatwia znalezienie właściwych programistów.

\subsection{Wady podejścia hybrydowego}
Największymi wadami podejścia hybrydowego są słabsza wydajność, błędy
pojawiające się tylko na określonych urządzeniach oraz różnorodne oczekiwania
użytkowników różnych platform. Użytkownik instalując aplikację hybrydową w taki sam sposób co 
natywną spodziewa się, że będzie ona działać niczym natywna. Tymczasem
dodatkowy narzut hybrydy, często w połączeniu z niechlujnie przygotowaną i nie
zoptymalizowaną aplikacją, prowadzi do mniej responsywnego interfejsu
użytkownika i w konskewencji do frustracji użytkownika. Częstym problemem przy
tworzeniu aplikacji mobilnych są błędy pojawiające się tylko na określonych
urządzeniach. Przy podejściu hybrydowym problem jest o tyle bardziej widoczny, że
najczęściej tworzymy rozwiązanie które ma być przenośne nie tylko pomiędzy urządzeniami w ramach jednej platformy, ale także między platformami. Co z oczywistych względów zwiększa przestrzeń urządzeń, które trzeba uzwględnić. Trzecim problemem hybryd jest kwestia
tworzenia interfejsu użytkownika. Dostawcy systemów operacyjnych dla urządzeń
mobilnych publikują zalecenia, co do tego jak powinien wyglądać interfejs aplikacji
działającej pod danym systemem. Zalecenia te są specyficzne dla platformy i często
wzajemnie się wykluczają. Przygotowanie jednej szaty graficznej i jednego interfejsu
może zostać źle odebrane przez użytkowników spodziewających się wyglądu
dostosowanego do platformy. Niestety stworzenie kilku wersji interfejsu jest dużo
bardziej pracochłonne i skomplikowane, niweczy także podstawową zaletę apliakcji
hybrydowych – przenośność. 
Są to poważne niedostatki, ale braki te można zniwelować poprzez skuteczne narzędzia.

\subsection{Propozycje rozwiązania problemów}
Ash ma za zadanie pomóc rozwiązać problemy zwiąne z wydajnością aplikacji oraz z
błędami pojawiającymi się tylko na określonych konfiguracjach sprzętowych. Aby
zapewnić wysoką wydajność działania aplikacji konieczny jest rygor w tworzeniu
wydajnego oprogramowania oraz możliwość testowania jej w sytuacjach które mogę
uwydatnić problemy z wydajnością. Dzięki funkcyjnemu podejściu do testowania
oprogramowania Ash pozwala na zbieranie informacji o responsywności interfejsu
oraz realistycznie symulować scenariusze dużego obciążenia. Programista
korzystający z Ash ma możliwość zdefiniowania w scenariuszach maksymalnego
czasu przebeigu testu, jeśli test nie zakończy się w założonym czasie test nie
powiedzie się. Niska responsywność interfejsu traktowana jest na równi z błędami
logiki czy prezentacji. Wymusza to na twórcy zadbanie o szybkość reakcji interfejsu.
Ash oferuje także możliwość chwilowego wyłączenia lub opóźnienia dostępu do
sieci. Sytuacje w których dostępność do internetu jest ograniczona są dość częste,
jednak niewiele aplikacji jest pisana biorąc to pod uwagę, jeszcze mniej jest
testowana pod tym kątem. Bardzo często problemy z dotępem objawiają się kiepską
wydajnością interfejsu lub długimi przestojami na ekranach ładowania. Ash pozwala
twórcom świadomie zmierzyć się z tym problemem. Ash wyposażony jest w
mechanizmy pozwalajace na łatwe uruchomienie na aplikacji na wielu urządzeniach
naraz, fizycznych jak i wirtualnych, także w zdalnych lokalizacjach. Sprawia to, że
użytkownicy są mają możliwość masowego uruchamiania testów na wszystkich
dostępnych im urządzeniach oraz są bardziej skłonni skorzystać z testów w czaseie
swojej pracy. Możliwość zdalnego uruchomienia testów daje możliwość stworzenia
rozproszonej bazy urządzeń, co pozwoli na testowanie także nietypowych
konfiguracji.

\subsection{Dlaczego Apache Cordova}
Jako bazę do implementacji wybrałem Apache Cordova. Apache Cordova jest to
wersja PhoneGap, którą korporacja Adobe (właściel praw do PhoneGap) udostępniła
fundacji Apache. Od tego momentu ten wariant technologii udostępniany jest
zasadzie otwartego źródła. Pomimo tego oba projekty są niemal identyczne, a jedyna
różnica faktyczna różnica między nimi jest natury prawnej. Głównym powodem
wyboru tej technologii jest spory udziała w rynku hybrydowych aplikacji mobilnych,
dynamizm rozwoju oraz liczna społeczność.

\subsection{Propozycje rozwiązania problemów}
Ash ma za zadanie pomóc rozwiązać problemy zwiąne z wydajnością aplikacji oraz z błędami pojawiającymi się tylko na określonych konfiguracjach sprzętowych. Aby zapewnić wysoką  wydajność działania aplikacji konieczny jest rygor w tworzeniu wydajnego oprogramowania oraz możliwość testowania jej w sytuacjach które mogę uwydatnić problemy z wydajnością. Dzięki funkcyjnemu podejściu do testowania oprogramowania Ash pozwala na zbieranie informacji o responsywności interfejsu oraz realistycznie symulować scenariusze dużego obciążenia. Programista korzystający z Ash ma możliwość zdefiniowania w scenariuszach maksymalnego czasu przebeigu testu, jeśli test nie zakończy się w założonym czasie test nie powiedzie się. Niska responsywność interfejsu traktowana jest na równi z błędami logiki czy prezentacji. Wymusza to na twórcy zadbanie o szybkość reakcji interfejsu. Ash oferuje także możliwość chwilowego wyłączenia lub opóźnienia dostępu do sieci. Sytuacje w których dostępność do internetu jest ograniczona są dość częste, jednak niewiele aplikacji jest pisana biorąc to pod uwagę, jeszcze mniej jest testowana pod tym kątem. Bardzo często problemy z dotępem objawiają się kiepską wydajnością interfejsu lub długimi przestojami na ekranach ładowania. Ash pozwala twórcom świadomie zmierzyć się z tym problemem. Ash wyposażony jest w mechanizmy pozwalajace na łatwe uruchomienie na aplikacji na wielu urządzeniach naraz, fizycznych jak i wirtualnych, także w zdalnych lokalizacjach. Sprawia to, że użytkownicy są mają możliwość masowego uruchamiania testów na wszystkich dostępnych im urządzeniach oraz są bardziej skłonni skorzystać z testów w czaseie swojej pracy. Możliwość zdalnego uruchomienia testów daje możliwość stworzenia rozproszonej bazy urządzeń, co pozwoli na testowanie także nietypowych konfiguracji. 

\subsection{Propozycje rozwiązania problemów}
Jako bazę do implementacji wybrałem Apache Cordova. Apache Cordova jest to wersja PhoneGap, którą korporacja Adobe (właściel praw do PhoneGap) udostępniła fundacji Apache. Od tego momentu ten wariant technologii udostępniany jest zasadzie otwartego źródła. Pomimo tego oba projekty są niemal identyczne, a jedyna różnica faktyczna różnica między nimi jest natury prawnej. Głównym powodem wyboru tej technologii jest spory udziała w rynku hybrydowych aplikacji mobilnych, dynamizm rozwoju oraz liczna społeczność.

\subsection{Test Driven Development}

\subsection{Hierarchia testów}

\section{Sposób użycia}
\subsection{Hello World}

\subsection{Getting Started}

\subsection{Filozofia}

\section{Przegląd funkcjonalności}
\subsection{Zmiana położenia ekranu}

\subsubsection{Opis}
Pozwala ustawić ekran w określonym położeniu - landscape lub portrait.

\subsubsection{Sposób użycia}

\subsection{Dostęp do sieci}

\subsubsection{Opis}
Daje możliwość manipulowania dostępem do sieci - opóźniać reakcję, zatrzymywać oraz przywracać połączenie.

\subsubsection{Sposób użycia}

\subsection{Dostęp do systemu plików}

\subsubsection{Opis}
Daje dostęp do systemu plików - pozwala na symulowanie dostępu do lokalnych plików oraz ich uploadu.

\subsubsection{Sposób użycia}

\subsection{Symulacja ruchu}

\subsubsection{Opis}
Ash dostarcza API umożliwiające symulowanie położenia lub ruchu między dwoma punktami.

\subsubsection{Sposób użycia}

\subsection{Obsługa przycisku powrotu}

\subsubsection{Opis}
Ta funkcjonalność symuluje naciśnięcie przycisku powrotu na telefonie.

\subsubsection{Sposób użycia}

\section{Zastosowania}
Ash został pomyślany jako biblioteka, która jest w stanie oprócz dostarczania "tradycyjnej" infrastruktury testowej, tzn.:
\begin{itemize}
  \item asercji
  \item funkcji porównujących
  \item loggerów
  \item narzędzi do budowanie testów
  \item ustandaryzowanych wyjątków
\end{itemize}
ułatwić także tesotwanie sytuacji, które są albo trudne do odtworzenia
\begin{itemize}
  \item operacje na plikach
  \item badanie widoczności elementu na ekranie
\end{itemize}
 albo w poza możliwościami typowych rozwiązań testujących
\begin{itemize}
  \item ustawienie ekranu urządzenia
  \item dostęp do sieci
  \item symulowanie ruchu
\end{itemize}
Ash może z powodzeniem być stosowany zarówno jako osobny (standalone) i samodzielny framework testujący, jak i uzupełnienie innych rozwiązań. W ogólnym ujęciu Ash jest przeznaczony do fukcyjnego testowania aplikacji, tzn. aplikacja jest testowana od strony interfejsu użytkownika, co ma swoje zalety (najbardziej wiarygodnie symuluje użytkownika) jak i wady (interfejs często podlega zmianom). Jak zostało wcześniej wspomniane testy funkcyjne dają najlepsze efekty, gdy są uzupełniane przez testy jednostkowe.  

\subsection{Problemy związane z obecnymi rozwiązaniami}

\subsection{Ash jako rozwiązanie}

\subsection{RWE - real world example}

\section{Architektura}

Ash dystrybuowany jest jako wtyczka do Apache Cordova z tego korzysta on także ze wszystkich mechanizmów typowych dla tego typu rozwiązań. Po dołączniu wtyczki do projektu np. za pomocą Crodova Command Line Interface w projekcie dostępny staje się globalny obiekt Ash, udostępniający wszystkie funkcjonalności biblioteki. 

Pola globalnego obiektu można podzielić na 3 grupy:  
\begin{itemize}
  \item proste funkcjonalności działające w sposób synchroniczny
  \item fukcje działające asynchronicznie i udostępniające złożoną funkcjonalność 
  \item prywatne, wewnętrzne pola oraz funkcje biblioteki
\end{itemize}
Warto podkreślić, że trzecia grupa nie wchodzi w skład oficjalnego, publicznego API Ash. Oznacza to, że o ile wiele z tych funkcjonalności czy helperów może być przydatna dla twórców testów, to nie rozsądnym jest korzystanie z nich bezposrednio, gdyż w przyszłych wersjach aplikacji w zależności od potrzeb kod ten może zostać zmieniony w sposób, który zmieni jego zachowanie lub/oraz API, co spowoduje niekompatybilność kodu testów z nową wersją Ash.

\subsection{Spojrzenie z lotu ptaka}

Ash definiuje funkcje pozwalajace na uruchamianie testów w kontekście pewnego zdarzenia sprzętowego, tj. możemy przygotować test, co do którego będziemy pewni, że w czasie jego działania będą zachodzić określone okoliczności. Możemy na przykład stworzyć test, który zostanie wykonany w sytuacji braku sieci np. w ten sposób:

\begin{lstlisting}
     //example.js

   //zdefiniuj kontekst braku sieci oraz uruchom w jego ramach przekazana funkcje
    Ash.noNetwork().then(function(){
	// tu mozemy umiescic kod testu
     	// zostanie on wykonany z kontekscie braku dostepu do sieci

	//tu powinien znalezc sie kod testujacy zachowanie aplikacji 
    });
\end{lstlisting}

Blok then pozwala zdefiniować co nastąpi po tym, jak sieć zostanie wyłączona. Jest to bardzo ważny aspekt biblioteki. Mamy pewność, że przez cały czas działania funkcji zachodzić będzie określony warunek. Warto zwrócić uwagę na przykładzie, że o ile w ramach kontektu stan sieci jest precyzyjnie zdefiniowany, to poza tymi ramami już tak nie musi być, stan możmy traktować jako dynamiczny lub nieokreślony. Dodatkowo należy pamiętać, że zmiana ustawień urządzenia w ramach kontekstu nie musi pociągać za sobą jego zmiany po wykonaniu testów. Ma to duże znaczenie z perspektywy testowania aplikacji, gdyż niejako wymusza, żeby w ramach jednego konteksu testować jedynie te rzeczy, które są z nim związane, a elementy interfesju które od nie zależą poza tym kontekstem.

Warto zaznaczyć, że konteksty można ze sobą łączyć, aby tworzyć bardziej złożone scenariusze. Takie złączenie realizujemy poprzez wilelokrotne użycie funkcji 'then' wraz z funkcjami, które chcemy wywyłać. Pozwala to na zdefiniowanie na przykład takiego kontekstu:

\begin{lstlisting}
     //example.js

    Ash.noNetwork().then(
	Ash.orientationHorizontal
    ).then(function(arg){
      	// w tym momencie mozemy byc pewni, ze zachodza dwa warunki:
	// 1) dostep do sieci zostal odciety 
	// 2) ekran znajduje sie w pozycji horyzontalnej

	//tu powinien znalezc sie kod testujacy zachowanie aplikacji 
    });
\end{lstlisting}

możemy także wywołania funckcji Ash przeplatać innym kodem JavaScript np. w ten sposób:

\begin{lstlisting}
     //example.js

    Ash.orientationHorizontal().then(function(msg){
	// tu mozemy umiescic kod JavaScript
      	
	// ekran jest w pozycji horyzontalnej
      
	// tu mozemy umieccic kod JavaScript
      	Ash.orientationVertical().then(function(){
		// tu mozemy umiescic kod JavaScript

        		// ekran jest w pozycji wertykalnej 

		// tu mozemy umiescic kod JavaScript
      	});
    });
\end{lstlisting}

\subsection{Promises}

Wewnętrznie Ash korzysta z mechanizmu obietnic tzw. Promise. Promises jest to mechanizm pozwalający programistom w lepszy prostszy i bardziej przejrzysty sposób panować nad  asynchronicznością. Dokładny opis mechanizmu, jego wymagania oraz zastosowania można znaleźć na  stronie projektu

\begin{quote}
http://promises-aplus.github.io/promises-spec/
\end{quote}

Na chwilę obecną nawet w samym JavaScript istnieje wiele implementacji specyfikacji Promises. W Ash pierwotnie zastosowano bibliotekę o nazwie promises.js dostępną pod adresem

\begin{quote}
https://github.com/then/promise/
\end{quote}

Za tym wyborem przemawiał niewielki rozmiar kodu (co ogranicza narzut związany z dodawaniem dodatkowej biblioteki do projektu korzystajacego z Ash) oraz bogactwo funkcjonalności (promises.js wiernie implementuje specyfikację oraz wzbogacając ją o kilka  nowych możliwości). Niestety szybko okazało się, że funkcjonalności oferowane przez promises.js nie do końca odpowiadają wymaganiom projektu. Biblioteka nie została jednak porzucona, ale zamiast tego zaadaptowana do specyficznych potrzeb Ash.  

\subsection{Organizacja testów. Run oraz Play}

Ash oferuje dwa podejścia do uruchamiania testów 'Run', o którym dalej będziemy nazywać "uruchamianiem testów" oraz 'Play', co dla rozróżnienia nazywiemy "odgrywaniem scenariuszy".

\subsubsection{Run}

Ten tryb oferuje proste API do szybkiego uruchamiania niezależnych od siebie testów. Sygnatura funkcji: 

\begin{quote}
function Ash.run(array[function] testsArray, function failureCallback[, function successCallback]) 
\end{quote}

Przykładowe zastosowanie: 

\begin{lstlisting}
     //example.js

    var exampleTests = [
	// tu umiesc funkcje z kodem testow
    ];

    Ash.run(exampleTests, function(errorData){
      // ten callback zostanie uruchomiony, za kazdym razem gdy test sie nie powiedzie
    }, function(successData){
      // ten callback jest opcjonalny, jesli zostanie podany to Ash uruchomi go za kazdym razem, gdy test sie powiedzie
    });
\end{lstlisting}

Run pozwala na sekwencyjne uruchomienie przekazanych testów w kolejności zgodnej z indeksem tablicy. Ash nie czyni żadnych zabiegów, aby testy nie kolidowały i nie ingerowały w działanie innych testów, dlatego testy przekazywane winny być od siebie nawzajem niezależne. Ash definiuje zestaw funkcji wyzwalaczy wołanych podczas uruchomienia Run. Funkcje te znajdują się w globalnym obiekcie Ash.callbacks, ale mogą być swobodnie nadpisywane przez użytkowników. 

\subsection{Obsługa błędów}

\subsection{Native bridge. Integracja z Apache Cordova}

\section{Implementacja}

\subsection{Zmiana położenia ekranu}

\subsection{Dostęp do sieci}

\subsection{Dostęp do systemu plików}

\subsection{Symulacja ruchu}

\subsection{Obsługa przycisku powrotu}

\section{Narzędzia oraz środowisko programisty}

\subsection{Rozpraszanie wykonania testów}

\subsection{Tworzenie laboratorium urządzeń}

\section{Dalsze kierunki rozwoju}

\end{document}